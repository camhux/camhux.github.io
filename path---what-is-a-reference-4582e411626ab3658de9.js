webpackJsonp([0xf9e17e3d45a4],{404:function(e,t){e.exports={data:{markdownRemark:{html:'<p>For beginning programmers, a common enough question. Studying the behaviors of objects in Java or JavaScript will lead you to mentions of "references" or "reference types". Go a little deeper, and you\'ll soon comb through discussions of “pass-by-value” versus “pass-by-<strong>reference</strong>” or admonitions about “<strong>referential</strong> equality” versus “structural equality”. The terminology is frequently dense and poorly defined; these obstacles compound with the fact that references are a subtle and abstract concept in their own right.</p>\n<p>In this post, I\'ll attempt to cultivate an understanding of object references as they exist in Java and JavaScript. Along the way, we\'ll consider the concepts of indirection and programming language semantics, which are important aspects of the design of object references. This is targeted at intermediate developers, but I hope that an ambitious beginner will find it accessible enough, or that an experienced programmer transitioning to a language with object references might still learn something useful.</p>\n<h2>Taxonomy</h2>\n<p>But, before getting into programming language semantics, there are first just... plain semantics. The term “reference”, even after we restrict ourselves to the domain of computing, can still be ambiguous. A reference, in the most general sense, is anything that <em>stands for</em> something else. In other words, a reference is anything that facilitates <em>indirection</em>. Each reference has a relation to another entity – called its <em>referent</em> – that the reference can retrieve or symbolize. Things like file handles and pointers facilitate indirection, so they fit this definition of “reference”, and abstract discussions of indirection may use the term “reference” to describe this entire category of <em>entities that point to other entities</em>.</p>\n<p>There’s also a more specific usage of “reference”, one which appears often in the context of Java and JavaScript. To distinguish this usage from the general one, I\'ll be using the term <em>object reference</em>, which is a hint as to the purpose of these references. Like other types of references, object references facilitate indirection, but they do so in a somewhat subtle way. Importantly, object references are sometimes one of the <em>only</em> language-level forms of indirection that a programming language offers, so grasping their role the language’s toolset (and their interactions with other parts of it) can be crucial for writing the most performant and coherent code.</p>\n<p>The majority of this post will focus on object references, with some mentions of other forms of indirection to highlight characteristics of object references.</p>\n<blockquote>\n<h2>Concept: Indirection</h2>\n<p>Humans are good at using arbitrary symbols to represent things. Without our refined ability to grant and understand names, we would be burdened to repeatedly describe complex things whenever we wanted to talk about them. You get a sample of how frustrating this would be when you try to jog someone’s memory of another person they have met, but whose name your listener doesn’t recognize: you have to grope to describe the third person’s appearance, traits, and relevance to the listener, hoping that the listener will be able to recover the link between the name and the complex being that the name represents. To be able to speak the name and have your listener <em>know</em> (or, <em>retrieve</em>) all of that information, without you having to reiterate details, leads to a fluent conversation that can get to the point (what you want to say <em>about</em> the third person) more quickly.</p>\n<p>Using a name to represent a complex, unwieldy thing in order to make it easier to talk about that thing is <em>indirection</em>. And, as in natural human language, indirection is one of the core capabilities of programming and machine languages. A fundamental form of indirection in computing is the <em>memory address</em>, a value in a cell of memory that indicates another location in the machine\'s memory. Like the naturalistic example above, computers use memory addresses to efficiently communicate about and manipulate complex patterns in memory that would be cumbersome or impossible to directly copy into every context where they\'re relevant.</p>\n</blockquote>\n<h2>Things that object references aren’t</h2>\n<p>Before digging into what makes object references what they are, there are a couple of common misconceptions to slay.</p>\n<ol>\n<li>\n<p>Object references are not pointers, although you will sometimes hear an old hand call an object reference a “pointer” out of habit – especially when describing a data structure that relies on indirection, like a linked list. If you’re still getting your head around indirection and its different manifestations, it helps to keep your nomenclature as unambiguous as possible. Learning about object references as “pointers” might add to your confusion if you learn about full-blown raw pointers later; or, if you understand pointers better than object references, conflating the two might hinder your uptake of the subtleties of object references.</p>\n<p>This point certainly isn\'t helped by Java\'s <code>NullPointerException</code> nomenclature. This exception occurs when an <em>object reference</em> is nulled out and receives an operation that expects a non-null object reference. Object references need to use pointers under the hood, so the name of the exception isn\'t <em>wrong</em>, but it exposes an implementation detail for little benefit. Oh well. (We\'ll talk more about object references versus pointers in a later section.)</p>\n</li>\n<li>\n<p>Object references are not categorically different from “values”.</p>\n<p>I’ve seen this confusion play out tens of times: (i) A new programmer posts on our beloved web to ask why their function that reassigns an argument doesn’t mutate the variable they pass in; (ii) a veteran responds with something about the language being “pass-by-value”, not “pass-by-reference”, and explains that mutating some part of an argument requires passing an object; (iii) the new programmer deduces that “values” and “references” are two poles of a dichotomy, without a nuanced understanding of how they’re different, and thinks that passing a object is synonymous with “pass-by-reference” behavior. Repeat this cycle enough and you end up with a proliferation of well-meaning <a href="https://codeburst.io/javascript-pass-by-value-and-pass-by-reference-in-javascript-fcf10305aa9c">blog</a> <a href="https://dev.to/twhite/javascript-vs-java-pass-by-value-and-reference">posts</a> teaching newcomers that JavaScript is <em>sometimes</em> pass-by-value and <em>sometimes</em> pass-by-reference.</p>\n<p><strong>Wrong!</strong> An object reference <em>is</em> a value. Both Java and JavaScript implement function calls strictly as “pass-by-value”; the values passed as arguments are always copied before they’re bound to the function’s declared parameters. But when you copy an object reference, the copy <em>shares a referent</em> with its source. This means that copies of object references allow <em>indirection</em> to shared mutable memory, while primitives like strings or integers do not, and mutating shared memory can be one purpose (or consequence) of indirection. (Plenty more on this later.)</p>\n</li>\n<li>\n<p>Object references are not synonymous with objects. This is a ticklish point that will occupy a large portion of the rest of this post, though, because object references are specifically designed to very transparently represent the object they refer to. Object references often <em>behave</em> as synonyms for objects, but they are distinct entities whose referential quality has meaningful consequences for code that manipulates them.</p>\n</li>\n</ol>\n<h2>What object references are</h2>\n<p>Finally, here’s the thesis:</p>\n<p>Object references are values that, via implicit indirection, transparently represent objects in a one-to-one reference-to-object relationship.</p>\n<h2>The semantics of object references</h2>\n<p>That “implicit indirection” is both the power and the ticklishness of object references. It means that, wherever an object reference appears, the language generally knows to treat it as if it were the <em>object</em> itself. From the programmer’s point of view, the object reference (as a discrete entity) is barely there – printing an object reference will print out some string representation of the object itself, attempting to read fields off an object reference will read those fields from the object, and so on.</p>\n<p>Hence, the ticklishness. A programmer can easily reason about the object\'s behaviors without thinking about the object reference because the object reference <em>is</em> her view of the object, per the language’s design. We informally talk about assigning and passing objects themselves, not object references, because that usually captures our meaning accurately enough. Objects are the <em>stuff</em>; object references are unobtrusive little handles we use to grab the objects. This unobtrusiveness of the object reference is a deliberate outcome of the semantics of Java and JavaScript.</p>\n<blockquote>\n<h2>Concept: Programming language semantics</h2>\n<p>‘Semantics (from Ancient Greek: σημαντικός sēmantikos, "significant") is the linguistic and philosophical study of meaning, in language, programming languages, formal logics, and semiotics.’ <a href="https://en.wikipedia.org/wiki/Semantics">Thank you, J. Wales.</a> 💙</p>\n<p>The heart of that definition is “meaning”, or “significance”. Without meaning, a language of any kind isn’t a language at all – meaning is <em>what</em> we communicate. The semantics of a programming language determines the relationship between written statements in code and what the machine will do when those statements are executed. (Really, it’s more accurate to say that the semantics determines how those statements are <em>translated</em> into a sequence of instructions that the machine can actually execute.)</p>\n<p>As an example, take a line of doggerel, fictional code:</p>\n<p><code>if node = node.next(), node { break ~node }</code></p>\n<p>Based on your experience with actual programming languages, how many different guesses can you make about what this line should ultimately do when it’s executed? It’s impossible to actually know the meaning with certainty, because the concrete written form of the code only <em>partially</em> expresses the meaning of the code that the machine will draw from it. The rest of the meaning is defined in the {compiler,interpreter,runtime} that will translate the code into an executable form, and you can’t recover that meaning from the written code alone.\nThrough study and experience, programmers build mental models of how different programming languages determine the meaning of the written code. This is the process of learning the <em>semantics</em>. Some aspects of programming language semantics are more intuitive than others, which is why I’m sitting here writing about object references in the first place.\n(An aside: Sterling code expresses as much of its meaning as possible, as clearly as possible. This can sometimes mean avoiding features of the language where simple syntactic forms belie tricky or quirky semantics. I say this regretfully, for I’m an admirer of JavaScript’s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator">comma operator</a>.)</p>\n</blockquote>\n<p>So, if object references <em>so transparently</em> represent objects, why do we need explicit knowledge of the reference at all? Isn’t it an implementation detail? Shouldn’t we just talk about “objects” as values and let the rest sit under the surface?</p>\n<p>These are valid questions, but ultimately, it’s important to understand and appreciate that objects in languages like Java and JavaScript are always represented with a form of indirection. It’s not an implementation detail; it\'s part of how the languages achieve their design goals.</p>\n<p>Contemplate one fact each about the type systems of Java and JavaScript:</p>\n<ul>\n<li>\n<p><strong>Polymorphism in Java relies on permitting subclasses to appear in places (variables, method parameters) where a superclass type is expected.</strong> Similarly, values of a type that implements an interface can appear in places that expect that interface type. When a variable or method parameter bears a general type like <code>Object</code>, the <em>concrete</em> type that will occupy that slot is still (generally) statically unknowable.</p>\n</li>\n<li>\n<p><strong>JavaScript\'s dynamic type system means objects are never restricted to a schema, and they can arbitrarily gain or lose properties at runtime.</strong> This means that a JavaScript object\'s representation in memory isn\'t fixed; a given variable or parameter binding can essentially make <em>zero</em> assumptions about the in-memory representation of its value, and indeed a single object\'s memory footprint may need to change over the course of its lifetime.</p>\n</li>\n</ul>\n<p>In each of these cases, there\'s uncertainty about the memory layout of the object. Many operations a computer does rely on knowing about the in-memory representation of values. The details, which are very interesting, nonetheless steer into the gritty territory of calling conventions, frame pointer offsets, and memory safety, and there isn\'t room for a detailed exploration of all that in this post. It\'s enough for now to realize that any variable whose value has a statically unknowable memory representation presents a challenge to a programming lanuage designer, because the machine can\'t directly work with a value of an unknown size. Function calls would fumble or misinterpret their arguments, variables after written with one value would evaluate to something different, the operating system would swat your program\'s knuckles constantly, and you would eventually want to toss your dev machine into Tartarus.</p>\n<p>But as we\'ve discussed, Java and JavaScript draw some of their core characteristics from the use of objects whose layouts are statically unknowable. This is one reason why object references exist: to act as handles of a <em>known size and layout</em> that allow the computer to retrieve and work with the dynamic object somewhere else in memory. Through indirection, object references act as liaisons to objects, compromising between the needs of the machine (strongly-defined value with known representation) and the programmer (object-oriented software designs).</p>\n<h3>Object references versus pointers</h3>\n<p>Object references aren\'t the only solution to the problem of dynamic object layouts. Anything that introduces a reference (in the general sense) that can dereference to the object will do. The other extremely common type of reference for this purpose is the pointer. Pointers are essentially direct (or "raw") representations of memory addresses, and they herald from the dawn of high-level programming languages, with object references being a later innovation. Pointers are ubiquitous in C/C++ and Go, and they\'re the tool of choice for substituting a reference for a dynamic region of memory in those languages.</p>\n<p>Conceptually, object references differ from pointers in two ways:</p>\n<ol>\n<li>\n<p><strong>Mechanism of dereference.</strong></p>\n<p>In a language with pointers, the programmer must use an appropriate operator to indicate where she wishes to retrieve the value that the pointer refers to. There\'s an <em>explicit syntax</em> for dereferencing; and, unless dereferenced, the pointer exists as a distinct entity that can be read and manipulated <em>as a pointer</em>. C programmers rely on manipulating pointers-as-pointers frequently.</p>\n<p>Languages with object references, by contrast, offer no means of examining the reference itself (or, if they do, it\'s an esoteric feature likely included for debugging, not a fundamental tool like pointer arithmetic in C). Instead, the name of the object reference can appear unadorned in expressions that intend to manipulate the underlying object. Object references automatically act as their corresponding objects as needed without any additional indication from the programmer.</p>\n<p>When do object references need to act like their referents? Not always, but frequently. Any expression that reads or writes the fields of an object will require a dereference. Method calls also require a dereference: In Java, barring optimizations, calling a method requires looking up an object\'s <a href="https://en.wikipedia.org/wiki/Virtual_method_table">vtable</a>, which lives behind the object reference (and is indeed a reason unto itself for the object reference in the first place). In JavaScript, method calls mean attempting a property read on the object itself as well as, potentially, cascading lookups on the prototype chain, neither of which can happen without a dereference.</p>\n<p>On the other hand, code that looks like it moves an object around doesn\'t actually need to touch the object. Assigning an object to a new variable (or a property in another object) semantically just <em>copies</em> the object reference. This also describes how object references are passed as function arguments in Java and JavaScript: they\'re copied and assigned to parameters in the body of the function, having become a new value but still dereferencing as needed to the same object. In fact, it can sometimes be a performance optimization to bundle some quantity of data into an object to allow passing it around without needing to copy all of it each time, as the size of the reference to be copied does not vary with the size of the object it refers to.</p>\n</li>\n<li>\n<p><strong>Reference-referent coupling.</strong></p>\n<p>Pointers generally allow their referent to be rewritten. When this happens, the value of the <em>pointer</em> doesn\'t change (i.e., it indicates the same address as before), but the value you get when you <em>dereference</em> does (the contents of the memory at that address have been completely overwritten). There is a <em>loose coupling</em> between the reference and the referent: the value of the referent can change without affecting the value of the reference.</p>\n<p>Object references couple the reference tightly to the referent. There is a one-to-one correspondence between an object reference and an object, and you never really have one without the other. (Remember how the object reference <em>is</em> our "view" of the object; we can\'t choose to hold the object directly.) You can overwrite the <em>reference</em> itself, like when you assign a new object to a variable that previously held a different one, but you can\'t overwrite the <em>object</em> without also changing the reference. This strengthens the "illusion" of object references – how they can automatically act as their referents when required – by obviating the need for any syntax that expresses changes to an object reference itself. It keeps their mental footprint light.</p>\n</li>\n</ol>\n<p>These distinguishing characteristics of object references are, again, examples of decisions that programming language designers made about semantics. Pointers, as relatively faithful representations of memory addresses, closely reflect the architectures of computers themselves; object references are a more abstract form of indirection whose behaviors fit into specific programming languages\' design goals and paradigms. (Of course, choosing to expose pointers as a feature to the programmer is <em>also</em> a design decision. But there were historically fewer alternatives.)</p>\n<h2>Object reference pitfalls</h2>\n<p>We now have a grip on what an object reference is and why they exist in quite the way they do. We haven\'t, however, hashed out some of the consequences of the semantics of references. Misunderstanding references is a truly common source of logical errors in code, and even practiced programmers sometimes slip up when working with objects.</p>\n<h3>Referential equality</h3>\n<p>"Referential equality" describes the relation that you evaluate when you use the equality operator (<code>==</code> in Java and JavaScript; <code>===</code> in wise JavaScript) to compare two object references. The boolean evaluation of the comparison reflects whether the <em>object references</em> are identical. This can be a source of confusion since the subtle masquerade of object references can lead programmers to believe that they are in fact comparing the equality of the objects themselves. It\'s not an unreasonable assumption to think that two objects should be "equal" when they contain the exact same data in their fields, but this is <em>not</em> what the equality operator compares when it compares objects in Java and JavaScript.</p>\n<p>This may be easiest to demonstrate with an example:</p>\n<pre><code class="language-java">class Dog {\n  String name;\n  Breed breed;\n\n  public Dog(String name, Breed breed) {\n      this.name = name;\n      this.breed = breed;\n  }\n}\n\n// elsewhere, in a method...\n\nDog fido1 = new Dog("fido", Breed.LABRADOODLE);\nDog fido2 = new Dog("fido", Breed.LABRADOODLE);\n\n// Is fido1 the same as fido2??\nif (fido1 == fido2) {\n    System.out.println("Who took my dog. You\'ll pay for this"); // &#x3C;== will not execute\n} else {\n    System.out.println("I guess there are just two different Fidos."); // &#x3C;== will execute; is a reasonable conclusion\n}\n</code></pre>\n<p><code>fido1</code> and <code>fido2</code>, despite having identical data in their fields, are distinct objects, which means they are handled through distinct object references. <code>==</code> evaluates to true <em>if and only if</em> the values of the object references being compared are identical, so <code>fido1 != fido2</code>.</p>\n<p>Consider what happens if we assign one of our <code>fido</code>s to a new variable, however:</p>\n<pre><code class="language-java">Dog unknownFido = fido2;\n</code></pre>\n<p>The value of the object reference for <code>fido2</code> is <em>copied</em> into <code>unknownFido</code>, and <code>fido2 == unknownFido</code> until one or both of them is reassigned.</p>\n<p>The converse of referential equality is "structural equality" (so named because it reflects the equality of two objects\' internal structures, not the identity of their references), and the idiomatic way to compare structural equality in Java is to call an override of <code>Object.equals</code>. This is an <em>idiom</em>, not a guarantee; I\'ve learned that <code>Array.equals</code> still just implements <a href="https://stackoverflow.com/questions/8777257/equals-vs-arrays-equals-in-java">referential equality</a> as an accident of history.</p>\n<p>There\'s no single idiomatic way to compare structural equality in JavaScript; you\'ll either need to use a <a href="https://lodash.com/docs/#isEqual">utility library</a> or code it up yourself.</p>\n<p>(A note: While "referential equality" is appearing in a "pitfalls" section, it unto itself is <em>not</em> a flaw or mistake. It\'s a sound extension of the semantics of object references. And, there are many problem spaces where comparing the identity of object references is the appropriate and intuitive behavior. It appears here solely for remarks as a common source of confusion.)</p>\n<h3>Shared mutable memory</h3>\n<p>When you copy an object reference by assigning it to a new variable or passing it to a function, you have now shared a region of memory to the new holder of the reference (an act usually called "aliasing"). Despite the tight coupling between the reference and its referent, the referent might still allow mutations to its data, and any mutations inside of that object will be visible to all holders of its corresponding object reference.</p>\n<p>This is a <em>classic</em> source of bugs, and some features of JavaScript make it particularly easy to fall for.</p>\n<ol>\n<li>\n<p><strong>The prototype-embedded reference.</strong> JavaScript does inheritance with prototype chains. Prototypes are a great place to put methods, but you might be tempted to use them to declare data or auxiliary objects, too. This is especially easy to do if you come at a prototype thinking it\'s just a variation of a Java class declaration:</p>\n<pre><code class="language-javascript">function Dog(name, breed) { /* .. */ }\n\nDog.prototype = {\n    bonesGathered: [], // ! WARNING: embedded reference! any lookup of `bonesGathered` on a Dog instance will access this single array!\n    fetch(bone) {\n        this.bonesGathered.push(bone); // ! WARNING: mutates shared memory!\n    },\n};\n</code></pre>\n<p>(Also, while I won\'t harp on it, it\'s a smell to overwrite the <code>prototype</code> property entirely. Prefer to define individual properties.)</p>\n<p>Solve this by initializing any objects that your instance needs in its constructor to ensure each instance has its own state.</p>\n</li>\n<li>\n<p><strong>The shallow copy.</strong> This goes for <code>Array.prototype.slice</code>, <code>Object.assign</code>, and any other procedure that copies properties from one object to another without explicitly reassuring you that it does a "deep copy". When these functions copy a property that holds an object reference, they do it by simple assignment, meaning the reference is aliased and shares a referent with the source. You may end up with a fresh array or object instance, but mutations inside of aliased objects will leak to copies. This can easily lead to unexpected behavior or race conditions (such as when multiple aliases of a single object reference embed in places where their state will mutate unpredictably over time).</p>\n<p>Once again, JavaScript has no canonical function or idiom for handling deep copies. You\'ll likely lean on a utility library of your choice. See lodash\'s <a href="https://lodash.com/docs/4.17.4#merge"><code>merge</code></a> and <a href="https://lodash.com/docs/4.17.4#cloneDeep"><code>cloneDeep</code></a> for examples. Be aware of the performance tradeoff of deep copies: your code may end up doing a lot more work traversing a hierarchy of nested objects.</p>\n</li>\n</ol>\n<p>Java, by offering <code>final</code> fields and idiomatically favoring accessor methods over publicly mutable fields, has some idiomatic defenses against mutability, but is still in principle susceptible to the same category of bug. JavaScript has <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"><code>Object.freeze</code></a> which makes an object\'s properties immutable. Freezing has its place in defensive code, but since it prevents mutations by throwing exceptions at runtime, it\'s not quite as convenient as the <code>final</code> fields that are checked at compile time in Java.  Note that <code>Object.freeze</code> is also a "shallow" operation and will not prevent deep mutations of embedded objects unless you recursively <code>freeze</code> them too.</p>\n<h2>In conclusion...</h2>\n<p>Object references are an important aspect of the semantics of Java and JavaScript, and they\'re worth understanding, if only to avoid related bugs and logical errors. They should be studied as deliberate features of these languages\' designs, not brushed away as implementation details. They <em>definitely</em> aren\'t pointers, but they are cousins.</p>\n<p>Above all, reference and indirection as concepts are elegant and important. References are not the solution to every problem in computing, but in many cases, they\'re the key ingredient of a supple, efficient design.</p>',frontmatter:{date:"January 19, 2018",path:"/what-is-a-reference",title:"What is a reference?"}}},pathContext:{}}}});
//# sourceMappingURL=path---what-is-a-reference-4582e411626ab3658de9.js.map